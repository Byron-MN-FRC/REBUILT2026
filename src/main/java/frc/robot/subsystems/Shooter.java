package frc.robot.subsystems;

import static edu.wpi.first.units.Units.Amps;
import static edu.wpi.first.units.Units.Volts;

import com.ctre.phoenix6.StatusCode;
import com.ctre.phoenix6.configs.TalonFXConfiguration;
import com.ctre.phoenix6.controls.MotionMagicVoltage;
import com.ctre.phoenix6.controls.VelocityVoltage;
import com.ctre.phoenix6.hardware.TalonFX;
import com.revrobotics.spark.SparkLowLevel.MotorType;
import com.revrobotics.spark.SparkMax;

import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
import edu.wpi.first.wpilibj2.command.Command;
import edu.wpi.first.wpilibj2.command.SubsystemBase;
import frc.robot.Constants;
import frc.robot.Robot;

public class Shooter extends SubsystemBase {
  public TalonFX leftShoot;
  
  public SparkMax shooterGateLeft;
  public SparkMax shooterGateRight;
  
  private final MotionMagicVoltage m_motionMagicVoltage = new MotionMagicVoltage(0).withSlot(0);
  
    final VelocityVoltage m_velocity = new VelocityVoltage(0);
  
    public double targetRPM = 300;
    private double openGatesSpeed = 0.5;
    private final double rpmTol = 25; // Tolerance in RPM
  
  public Shooter() {
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
    leftShoot = new TalonFX(24, Robot.getInstance().m_CANivore2);
    
    shooterGateLeft = new SparkMax(21, MotorType.kBrushless);
    shooterGateRight = new SparkMax(22, MotorType.kBrushless);
    
    TalonFXConfiguration configs = new TalonFXConfiguration();
    
    /*
    * Voltage-based velocity requires a velocity feed forward to account for the
     * back-emf of the motor
     */
    configs.Slot0.kS = 0.1; // To account for friction, add 0.1 V of static feedforward
    configs.Slot0.kV = 0.12; // Kraken X60 is a 500 kV motor, 500 rpm per V = 8.333 rps per V, 1/8.33 = 0.12
                             // volts / rotation per second
    configs.Slot0.kP = 0.11; // An error of 1 rotation per second results in 0.11 V output
    configs.Slot0.kI = 0; // No output for integrated error
    configs.Slot0.kD = 0; // No output for error derivative
    // Peak output of 8 volts
    configs.Voltage.withPeakForwardVoltage(Volts.of(8))
        .withPeakReverseVoltage(Volts.of(-8));

    /*
    * Torque-based velocity does not require a velocity feed forward, as torque
    * will accelerate the rotor up to the desired velocity by itself
     */
    configs.Slot1.kS = 2.5; // To account for friction, add 2.5 A of static feedforward
    configs.Slot1.kP = 5; // An error of 1 rotation per second results in 5 A output
    configs.Slot1.kI = 0; // No output for integrated error
    configs.Slot1.kD = 0; // No output for error derivative
    // Peak output of 40 A
    configs.TorqueCurrent.withPeakForwardTorqueCurrent(Amps.of(40))
        .withPeakReverseTorqueCurrent(Amps.of(-40));

    /* Retry config apply up to 5 times, report if failure */
    StatusCode status = StatusCode.StatusCodeNotInitialized;
    for (int i = 0; i < 5; ++i) {
      status = leftShoot.getConfigurator().apply(configs);
      if (status.isOK())
        break;
    }
    if (!status.isOK()) {
      System.out.println("Could not apply configs, error code: " + status.toString());
    }

    SmartDashboard.putNumber("Shooter Set RPM", 0);
  }

  @Override
  public void periodic() {
    
    if (Constants.Debug.DEBUG_MODE) {
      SmartDashboard.putNumber("Shooter RPM", leftShoot.getVelocity().getValueAsDouble() * 60.0);
      SmartDashboard.putBoolean("Shooter Ready", isAtTargetRPM());
    }
  
    spinKrakens(targetRPM);

  }

  @Override
  public void simulationPeriodic() {
    // This method will be called once per scheduler run when in simulation
  }

  public boolean isAtTargetRPM() {
    double currentRPM = leftShoot.getVelocity().getValueAsDouble() * 60.0;
    return (targetRPM > 0) && (Math.abs(currentRPM - targetRPM) <= rpmTol);
  }

  public void openGates(double speed) {
    shooterGateLeft.set(speed);
    shooterGateRight.set(-speed);
  }

  public void stopGates() {
    shooterGateLeft.set(0);
    shooterGateRight.set(0);
  }

  public void stopAll() {
    // TODO this currently only stops the shooter for a single cycle, because
    // targetRPM is still set above zero and being called in periodic()

    spinKrakens(0);
    stopGates();
  }

  public void spinKrakens(double rpm) {
    // TODO currently the RPM parameter is unused, in favor of SmartDashboard value
    double targetRPS = SmartDashboard.getNumber("Shooter Set RPM", 0) / 60.0;
    leftShoot.setControl(m_velocity.withVelocity(targetRPS));
  }

  public Command spinKraken() {
    return run(() -> spinKrakens(targetRPM))
        .until(this::isAtTargetRPM)
        .andThen(
            run(() -> {
              spinKrakens(targetRPM);
              openGates(openGatesSpeed);
            }));

  }

}

package frc.robot.subsystems;

import static edu.wpi.first.units.Units.Amps;
import static edu.wpi.first.units.Units.Volts;

import javax.crypto.spec.RC2ParameterSpec;

import com.ctre.phoenix6.StatusCode;
import com.ctre.phoenix6.configs.CurrentLimitsConfigs;
import com.ctre.phoenix6.configs.TalonFXConfiguration;
import com.ctre.phoenix6.controls.MotionMagicVoltage;
import com.ctre.phoenix6.controls.VelocityVoltage;
import com.ctre.phoenix6.hardware.TalonFX;
import com.ctre.phoenix6.signals.InvertedValue;
import com.revrobotics.spark.SparkLowLevel.MotorType;
import com.revrobotics.spark.config.SparkMaxConfig;
import com.revrobotics.PersistMode;
import com.revrobotics.ResetMode;
import com.revrobotics.spark.SparkMax;

import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
import edu.wpi.first.wpilibj2.command.Command;
import edu.wpi.first.wpilibj2.command.SubsystemBase;
import frc.robot.Constants;
import frc.robot.DistanceVelocityMap;
import frc.robot.Robot;

public class Shooter extends SubsystemBase {
  public TalonFX leftShoot;

  public SparkMax shooterGate;
  public SparkMax shooterMagazine;

  private final MotionMagicVoltage m_motionMagicVoltage = new MotionMagicVoltage(0).withSlot(0);

  final VelocityVoltage m_velocity = new VelocityVoltage(0);

  public double targetRPM = 2100;

  private double openGatesSpeed = 1;
  private final double rpmTol = 125; // Tolerance in RPM

  public Shooter() {
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
    leftShoot = new TalonFX(24, Constants.TurretShooterConstants.CAN_BUS);

    shooterGate = new SparkMax(21, MotorType.kBrushless);
    shooterMagazine = new SparkMax(22, MotorType.kBrushless);

    SparkMaxConfig gateConfig = new SparkMaxConfig();
    SparkMaxConfig magazineConfig = new SparkMaxConfig();

    gateConfig.smartCurrentLimit(15); // Limit gate motor current to 10 A
    magazineConfig.smartCurrentLimit(30); // Limit gate motor current to 10 A

    gateConfig.inverted(false); // Invert left gate motor direction
    magazineConfig.inverted(false); // Invert right gate motor direction

    shooterGate.configure(gateConfig, ResetMode.kResetSafeParameters, PersistMode.kPersistParameters);
    shooterMagazine.configure(magazineConfig, ResetMode.kResetSafeParameters, PersistMode.kPersistParameters);

    TalonFXConfiguration configs = new TalonFXConfiguration();
    configs.CurrentLimits.SupplyCurrentLimit = 70; // Limit motor supply current to 40
    configs.CurrentLimits.StatorCurrentLimit = 40;

    configs.MotorOutput.Inverted = InvertedValue.CounterClockwise_Positive;

    /*
     * Voltage-based velocity requires a velocity feed forward to account for the
     * back-emf of the motor
     */
    configs.Slot0.kS = 0.376; // 0.1; // To account for friction, add 0.1 V of static feedforward
    configs.Slot0.kV = 0.115; // Kraken X60 is a 500 kV motor, 500 rpm per V = 8.333 rps per V, 1/8.33 = 0.12
                              // volts / rotation per second
    configs.Slot0.kP = 0.012; // 0.11; // An error of 1 rotation per second results in 0.11 V output
    configs.Slot0.kI = 0.0001; // No output for integrated error
    configs.Slot0.kD = 0; // No output for error derivative
    // Peak output of 8 volts
    configs.Voltage.withPeakForwardVoltage(Volts.of(8))
        .withPeakReverseVoltage(Volts.of(-8));

    // /*
    // * Torque-based velocity does not require a velocity feed forward, as torque
    // * will accelerate the rotor up to the desired velocity by itself
    // */
    // configs.Slot1.kS = 2.5; // To account for friction, add 2.5 A of static
    // feedforward
    // configs.Slot1.kP = 5; // An error of 1 rotation per second results in 5 A
    // output
    // configs.Slot1.kI = 0; // No output for integrated error
    // configs.Slot1.kD = 0; // No output for error derivative
    // // Peak output of 40 A
    // configs.TorqueCurrent.withPeakForwardTorqueCurrent(Amps.of(40))
    // .withPeakReverseTorqueCurrent(Amps.of(-40));

    /* Retry config apply up to 5 times, report if failure */
    StatusCode status = StatusCode.StatusCodeNotInitialized;
    for (int i = 0; i < 5; ++i) {
      status = leftShoot.getConfigurator().apply(configs);
      if (status.isOK())
        break;
    }
    if (!status.isOK()) {
      System.out.println("Could not apply configs, error code: " + status.toString());
    }

    if (Constants.Debug.DEBUG_MODE) {
      SmartDashboard.putData("Subsystem: Shooter", this);
      SmartDashboard.putNumber("Shooter Set RPM", 0);
    }
  }

  @Override
  public void periodic() {

    if (Constants.Debug.DEBUG_MODE) {
      SmartDashboard.putNumber("Shooter RPM", leftShoot.getVelocity().getValueAsDouble() * 60.0);
      SmartDashboard.putBoolean("Shooter Ready", isAtTargetRPM());
    }

    // spinKrakens(targetRPM);

    targetRPM = DistanceVelocityMap.getVelocity(0);

  }

  @Override
  public void simulationPeriodic() {
    // This method will be called once per scheduler run when in simulation
  }

  public boolean isAtTargetRPM() {
    double currentRPM = leftShoot.getVelocity().getValueAsDouble() * 60.0;
    return (targetRPM > 0) && (Math.abs(currentRPM - targetRPM) <= rpmTol);
  }

  public void openGates(double speed) {
    shooterGate.set(speed);
    shooterMagazine.set(-speed);
  }

  public void stopGates() {
    shooterGate.set(0);
    shooterMagazine.set(0);
  }

  public void stopAll() {
    // TODO this currently only stops the shooter for a single cycle, because
    // targetRPM is still set above zero and being called in periodic()

    spinShooter(0);
    stopGates();
  }

  public void spinShooter(double rpm) {
    // TODO currently the RPM parameter is unused, in favor of SmartDashboard value
    // double targetRPS = SmartDashboard.getNumber("Shooter Set RPM", 0) / 60.0;
    double targetRPS = rpm / 60.0;
    leftShoot.setControl(m_velocity.withVelocity(targetRPS));
  }

  public void spinCommandShooter() {

    spinShooter(targetRPM);
    if (isAtTargetRPM()) {
      openGates(openGatesSpeed);
    } else {
      stopGates();
    }
  }
}

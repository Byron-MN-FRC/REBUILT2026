// RobotBuilder Version: 6.1
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

// ROBOTBUILDER TYPE: Subsystem.

package frc.robot.subsystems;

import com.ctre.phoenix6.StatusCode;
import com.ctre.phoenix6.configs.CurrentLimitsConfigs;
import com.ctre.phoenix6.controls.NeutralOut;
import com.ctre.phoenix6.controls.PositionTorqueCurrentFOC;
import com.ctre.phoenix6.controls.PositionVoltage;
import com.revrobotics.PersistMode;
import com.revrobotics.ResetMode;
import com.ctre.phoenix6.hardware.TalonFX;
import com.ctre.phoenix6.signals.NeutralModeValue;
import com.revrobotics.spark.SparkLowLevel.MotorType;
import com.revrobotics.spark.SparkMax;
import com.revrobotics.spark.config.SparkMaxConfig;

import edu.wpi.first.wpilibj.DigitalInput;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
import edu.wpi.first.wpilibj2.command.SubsystemBase;
import frc.robot.Constants;
import frc.robot.Robot;
import frc.robot.subsystems.ClimbSubsystem.LockdownMode;

// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS

/**
 *
 */
public class Hopper extends SubsystemBase {
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    private SparkMax leftFuelGrabber;
    private SparkMax rightFuelGrabber;
    private SparkMax hopperFloorTransferSecure;
    private TalonFX hopperExtendMotor;
    // ArmoredCoreAC v4Rusty;

    private DigitalInput hopperExtendSwitch;
    private DigitalInput hopperRetractSwitch;
    // Motor control modes
    private final NeutralOut m_brake = new NeutralOut();

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

    public boolean isExtending = false;

    /**
    *
    */
    public Hopper() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS

        if (Constants.Debug.INTAKE_EXISTS) {
            leftFuelGrabber = new SparkMax(16, MotorType.kBrushless);
            rightFuelGrabber = new SparkMax(15, MotorType.kBrushless);
 
            SparkMaxConfig leftFuelGrabberConfigLeft = new SparkMaxConfig();
            SparkMaxConfig rightFuelGrabberConfigRight = new SparkMaxConfig();

            leftFuelGrabberConfigLeft.smartCurrentLimit(10); // Limit gate motor current to 10 A
            rightFuelGrabberConfigRight.smartCurrentLimit(10); // Limit gate motor current to 10 A

            leftFuelGrabber.configure(leftFuelGrabberConfigLeft, ResetMode.kResetSafeParameters,
                    PersistMode.kPersistParameters);
            rightFuelGrabber.configure(rightFuelGrabberConfigRight, ResetMode.kResetSafeParameters,
                    PersistMode.kPersistParameters);

            leftFuelGrabber.configure(leftFuelGrabberConfigLeft, ResetMode.kResetSafeParameters,
                    PersistMode.kPersistParameters);
            rightFuelGrabber.configure(rightFuelGrabberConfigRight, ResetMode.kResetSafeParameters,
                    PersistMode.kPersistParameters);

            hopperExtendMotor = new TalonFX(17);

            // Configure current limiting (10 amps)
            CurrentLimitsConfigs currentLimits = new CurrentLimitsConfigs()
                    .withStatorCurrentLimit(Constants.IntakeHopperConstants.CURRENT_LIMIT);

            // Set neutral mode to brake
            hopperExtendMotor.setNeutralMode(NeutralModeValue.Brake);

            /* Retry config apply up to 5 times, report if failure */
            StatusCode status = StatusCode.StatusCodeNotInitialized;
            for (int i = 0; i < 5; ++i) {
                status = hopperExtendMotor.getConfigurator().apply(currentLimits);
                if (status.isOK())
                    break;
            }
            if (!status.isOK()) {
                System.out.println("Could not apply configs, error code: " + status.toString());
            }
        }

        hopperFloorTransferSecure = new SparkMax(18, MotorType.kBrushless); //floor motor
        SparkMaxConfig hopperFloorTransferSecureConfig = new SparkMaxConfig();
        hopperFloorTransferSecureConfig.smartCurrentLimit(10); // Limit gate motor current to 10 A
        hopperFloorTransferSecureConfig.inverted(true); // Invert direction of floor transfer motor
        hopperFloorTransferSecure.configure(hopperFloorTransferSecureConfig, ResetMode.kResetSafeParameters,
                PersistMode.kPersistParameters);

        if (Constants.Debug.INTAKE_EXISTS) {
            hopperExtendSwitch = new DigitalInput(0);
            addChild("hopperExtendSwitch", hopperExtendSwitch);

            hopperRetractSwitch = new DigitalInput(1);
            addChild("hopperRetractSwitch", hopperRetractSwitch);
        }
        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS

    }

    @Override
    public void periodic() {
        // This method will be called once per scheduler run
        if (Constants.Debug.DEBUG_MODE) {
            if (Constants.Debug.INTAKE_EXISTS) {
                SmartDashboard.putBoolean("Hopper Extended", isHopperExtended());
                SmartDashboard.putBoolean("Hopper Retracted", isHopperRetracted());
            }
            SmartDashboard.putNumber("Hopper Floor Transfer Speed", hopperFloorTransferSecure.get());
        }

        // Check lockdown mode
        if (Robot.getInstance().m_climb.currentLockdownMode == LockdownMode.full ||
                Robot.getInstance().m_climb.currentLockdownMode == LockdownMode.partial) {
            // In lockdown mode, ensure hopper is retracted
            // setHopperRetract();
            if (!isExtending()) {
                setHopperRetract();
            }
        }

        hopperExtendMotorControl();
    }

    @Override
    public void simulationPeriodic() {
        // This method will be called once per scheduler run when in simulation
    }

    // Put methods for controlling this subsystem
    // here. Call these from Commands.

    public void setFuelGrabberSpeed() {
        if (Constants.Debug.INTAKE_EXISTS) {
            leftFuelGrabber.set(0.5);
            rightFuelGrabber.set(-0.5);
        }
    }

    public void stopFuelGrabber() {
        if (Constants.Debug.INTAKE_EXISTS) {
            leftFuelGrabber.set(0);
            rightFuelGrabber.set(0);
        }
    }

    public void setHopperFloorTransferSecureSpeed(double speed) {
        hopperFloorTransferSecure.set(speed);
    }

    public void stopHopperFloorTransferSecure() {
        hopperFloorTransferSecure.set(0);
    }

    public void ifIntakeJammed() {
        if (Constants.Debug.INTAKE_EXISTS) {
            leftFuelGrabber.set(-0.1);
            rightFuelGrabber.set(-0.1);
        }
    }

    public void clearIntakeJam() {
        if (Constants.Debug.INTAKE_EXISTS) {
            leftFuelGrabber.set(0);
            rightFuelGrabber.set(0);
        }
    }

    public void ifHopperFloorTransferSecureIsBlocked() {
        hopperFloorTransferSecure.set(-0.1);
    }

    public void clearHopperFloorTransferSecureBlockage() {
        hopperFloorTransferSecure.set(0);
    }

    public void setHopperExtend() {
        if (Robot.getInstance().m_climb.currentLockdownMode == LockdownMode.full ||
                Robot.getInstance().m_climb.currentLockdownMode == LockdownMode.partial) {
            // In lockdown mode, don't extend
            return;
        } else {
            isExtending = true;

            if (Constants.Debug.DEBUG_MODE)
                System.out.println("Extending hopper");
        }
    }

    public void setHopperRetract() {
        isExtending = false;

        if (Constants.Debug.DEBUG_MODE)
            System.out.println("Retracting hopper");
    }

    public void retractingHopperForLockdown() {
        setHopperRetract();

    }

    public boolean isHopperExtended() {
        if (Constants.Debug.INTAKE_EXISTS) {
            return hopperExtendSwitch.get();
        } else {
            return false; // Assume not extended when intake doesn't exist
        }
    }

    public boolean isHopperRetracted() {
        if (Constants.Debug.INTAKE_EXISTS) {
            return hopperRetractSwitch.get();
        } else {
            return true; // Assume retracted when intake doesn't exist
        }
    }

    public boolean isExtending() {
        return isExtending;
    }

    public void hopperExtendMotorControl() {
        if (Constants.Debug.INTAKE_EXISTS) {
            if (isExtending) {
                if (!isHopperExtended()) {
                    if (Constants.Debug.DEBUG_MODE) SmartDashboard.putString("check", "extend");
                    hopperExtendMotor.set(Constants.IntakeHopperConstants.EXTEND_SPEED); // Extend at half speed
                } else {
                    hopperExtendMotor.set(0); // Stop when fully extended
                }
            } else {
                if (!isHopperRetracted()) {
                    if (Constants.Debug.DEBUG_MODE) SmartDashboard.putString("check", "retract");
                    hopperExtendMotor.set(Constants.IntakeHopperConstants.RETRACT_SPEED); // Retract at half speed
                } else {
                    hopperExtendMotor.set(0); // Stop when fully retracted
                }
            }
        }
    }

    public void forwardForAgitate() {
        hopperFloorTransferSecure.set(Constants.IntakeHopperConstants.AGITATE_COMMAND_SPEED);
    }

    public void reverseForAgitate() {
        hopperFloorTransferSecure.set(-Constants.IntakeHopperConstants.AGITATE_COMMAND_SPEED);
    }

    public void stopAll() {
        stopFuelGrabber();
        stopHopperFloorTransferSecure();

    }
}